# Linux 文件体系

Linux 以文件的形式对计算机中的数据和硬件资源进行管理，也就是彻底的一切皆文件，反映在 Linux 的文件类型上就是:普通文件、目录文件(也就是文件夹)、设备文件、链接文件、管道文件、套接字文件(数据通信的接口)等等。而这些种类繁多的文件被 Linux 使用目录树进行管理， 所谓的目录树就是以根目录(/)为主，向下呈现分支状的一种文件结构。不同于纯粹的 ext2 之类的文件系统，我把它称为文件体系，一切皆文件和文件目录树的资源管理方式一起构成了 Linux 的文件体系，让 Linux 操作系统可以方便使用系统资源。

所以文件系统比文件体系涵盖的内容少很多，Linux 文件体系主要在于把操作系统相关的东西用文件这个载体实现:文件系统挂载在操作系统上，操作系统整个系统又放在文件系统里。但本文中文件体系的相关内容不是很多，大部分地方都可以用文件系统代替文件体系。

## Linux 中的文件类型

那就先简单说说 Linux 中的文件类型，主要关注普通文件、目录文件和符号连接文件。

1. 普通文件(`-`)

   - 从 Linux 的角度来说，类似 mp4、pdf、html 这样应用层面上的文件类型都属于普通文件

   - Linux 用户可以根据访问权限对普通文件进行查看、更改和删除

2. 目录文件(`d`，directory file)

   - 目录文件对于用惯 Windows 的用户来说不太容易理解，目录也是文件的一种

   - 目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件(普通文件的执行权限就是目录文件的访问权限)，但是只有内核的进程能够修改它们

   - 虽然不能修改，但是我们能够通过 vim 去查看目录文件的内容

3. 符号链接(`l`，symbolic link)

   - 这种类型的文件类似 Windows 中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接

4. 块设备文件(b，block)和字符设备文件(c，char)

   这些文件一般隐藏在 `/dev` 目录下，在进行设备读取和外设交互时会被使用到。比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件

   系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外

5. FIFO(p，pipe)

   管道文件主要用于进程间通讯。比如使用 `mkfifo` 命令可以创建一个 FIFO 文件，启用一个进程 A 从 FIFO 文件里读数据，启动进程 B 往 FIFO 里写数据，先进先出，随写随读。

6. 套接字(s，socket)

   用于进程间的网络通信，也可以用于本机之间的非网络通信

   这些文件一般隐藏在`/var/run`目录下，证明着相关进程的存在

Linux 的文件是没有所谓的扩展名的，一个 Linux 文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 `x` ，比如`[ -rwx-r-xr-x ]` 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows 下能被执行的文件扩展名通常是 `.com` `.exe` `.bat` 等不同。

不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 `-rwxrwxrwx` 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 `x` 代表这个文件具有可执行的能力，但是能不能执行成功，当然就得要看该文件的内容了。

虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。

所以 Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的 `/bin/ls`，这个显示文件属性的指令要是权限被修改为无法执行，那么 `ls` 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你的 Linux 系统中，文件的属性权限确实是会被改变的

### Linux 目录树

对 Linux 系统和用户来说，所有可操作的计算机资源都存在于目录树这个逻辑结构中，对计算机资源的访问都可以认为是目录树的访问。就硬盘来说，所有对硬盘的访问都变成了对目录树中某个节点也就是文件夹的访问，访问时不需要知道它是硬盘还是硬盘中的文件夹。
目录树的逻辑结构也非常简单，就是从根目录(`/`)开始，不断向下展开各级子目录。

硬盘分区
硬盘分区是硬盘结合到文件体系的第一步，本质是「硬盘」这个物理概念转换成「区」这个逻辑概念，为下一步格式化做准备。
所以分本身并不是必须的，你完全可以把一整块硬盘作为一个区。但从数据的安全性以及系统性能角度来看，分区还是有很多用处的，所以一般都会对硬盘进行分区。

讲分区就不得不先提每块硬盘上最重要的第一扇区，这个扇区中有硬盘主引导记录(Master boot record, MBR) 及分区表(partition table)， 其中 MBR 占有 446 bytes，而分区表占有 64 bytes。硬盘主引导记录放有最基本的引导加载程序，是系统开机启动的关键环节，在附录中有更详细的说明。而分区表则跟分区有关，它记录了硬盘分区的相关信息，但因分区表仅有 64bytes ， 所以最多只能记彔四块分区(分区本身其实就是对分区表进行设置)。

只能分四个区实在太少了，于是就有了扩展分区的概念，既然第一个扇区所在的分区表只能记录四条数据， 那我可否利用额外的扇区来记录更多的分区信息。
把普通可以访问的分区称为主分区，扩展分区不同于主分区，它本身并没有内容，它是为进一步逻辑分区提供空间的。在某块分区指定为扩展分区后，就可以对这块扩展分区进一步分成多个逻辑分区。操作系统规定:

1. 四块分区每块都可以是主分区或扩展分区
1. 扩展分区最多只能有一个(也没必要有多个)
1. 扩展分区可以进一步分割为多个逻辑分区
1. 扩展分区只是逻辑概念，本身不能被访问，也就是不能被格式化后作为数据访问的分区，能够作为数据访问的分区只有主分区和逻辑分区
1. 逻辑分区的数量依操作系统而不同，在 Linux 系统中，IDE 硬盘最多有 59 个逻辑分区(5 号到 63 号)， SATA 硬盘则有 11 个逻辑分区(5 号到 15 号)

一般给硬盘进行分区时，一个主分区一个扩展分区，然后把扩展分区划分为 N 个逻辑分区是最好的

::: tip
是否可以不要主分区呢？不知道，但好像不用管，你创建分区的时候会自动给你配置类型

特殊的，你最好单独分一个 swap 区(内存置换空间)，它独为一类，功能是:当有数据被存放在物理内存里面，但是这些数据又不是常被 CPU 所取用时，那么这些不常被使用的程序将会被丢到硬盘的 swap 置换空间当中， 而将速度较快的物理内存空间释放出来给真正需要的程序使用
:::

## 格式化

我们知道 Linux 操作系统支持很多不同的文件系统，比如 ext2、ext3、XFS、FAT 等等，而 Linux 把对不同文件系统的访问交给了 VFS(虚拟文件系统)，VFS 能访问和管理各种不同的文件系统。所以有了区之后就需要把它格式化成具体的文件系统以便 VFS 访问。

标准的 Linux 文件系统 Ext2 是使用「基于 inode 的文件系统」

1. 我们知道一般操作系统的文件数据除了文件实际内容外， 还带有很多属性，例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、 时间参数等)，文件系统通常会将属性和实际内容这两部分数据分别存放在不同的区块

1. 在基于 inode 的文件系统中，权限与属性放置到 inode 中，实际数据放到 data block 区块中，而且 inode 和 data block 都有编号

Ext2 文件系统在此基础上

1. 文件系统最前面有一个启动扇区(boot sector)。这个启动扇区可以安装开机管理程序， 这个设计让我们能将不同的引导装载程序安装到个别的文件系统前端，而不用覆盖整个硬盘唯一的 MBR， 也就是这样才能实现多重引导的功能

2. 把每个区进一步分为多个块组 (block group)，每个块组有独立的 `inode/block` 体系

如果文件系统高达数百 GB 时，把所有的 inode 和 block 通通放在一起会因为 inode 和 block 的数量太庞大，不容易管理

这其实很好理解，因为分区是用户的分区，实际计算机管理时还有个最适合的大小，于是计算机会进一步的在分区中分块

(但这样岂不是可能出现大文件放不了的问题？有什么机制善后吗？)

每个块组实际还会分为分为 6 个部分，除了 inode table 和 data block 外还有 4 个附属模块，起到优化和完善系统性能的作用

inode table
主要记录文件的属性以及该文件实际数据是放置在哪些 block 中，它记录的信息至少有这些:

大小、真正内容的 block 号码(一个或多个)

访问模式(read/write/excute)

拥有者与群组(owner/group)

各种时间:建立或状态改变的时间、最近一次的读取时间、最近修改的时间

没有文件名！文件名在目录的 block 中！

一个文件占用一个 inode，每个 inode 有编号

Linux 系统存在 inode 号被用完但磁盘空间还有剩余的情况

注意，这里的文件不单单是普通文件，目录文件也就是文件夹其实也是一个文件，还有其他的也是

inode 的数量与大小在格式化时就已经固定了，每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)

文件系统能够建立的文件数量与 inode 的数量有关，存在空间还够但 inode 不够的情况

系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容

inode 要记录的资料非常多，但偏偏又只有 128bytes ， 而 inode 记录一个 block 号码要花掉 4byte ，假设我一个文件有 400MB 且每个 block 为 4K 时， 那么至少也要十万条 block 号码的记录！inode 哪有这么多空间来存储？为此我们的系统很聪明的将 inode 记录 block 号码的区域定义为 12 个直接，一个间接, 一个双间接与一个三间接记录区(详细见附录)
data block
放置文件内容数据的地方

在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode 的记录

原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)

在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种，由于 block 大小的区别，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量各不相同:

Block 大小 1KB 2KB 4KB

最大单一档案限制 16GB 256GB 2TB

最大档案系统总容量 2TB 8TB 16TB

每个 block 内最多只能够放置一个文件的资料，但一个文件可以放在多个 block 中(大的话)

若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)

所以如果你的档案都非常小，但是你的 block 在格式化时却选用最大的 4K 时，可能会产生容量的浪费

既然大的 block 可能会产生较严重的磁碟容量浪费，那么我们是否就将 block 大小定为 1K ？这也不妥，因为如果 block 较小的话，那么大型档案将会占用数量更多的 block ，而 inode 也要记录更多的 block 号码，此时将可能导致档案系统不良的读写效能

事实上现在的磁盘容量都太大了，所以一般都会选择 4K 的 block 大小

superblock
记录整个文件系统相关信息的地方，一般大小为 1024bytes，记录的信息主要有:

block 与 inode 的总量

未使用与已使用的 inode / block 数量

一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1

block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128bytes 或 256bytes)；

其他各种文件系统相关信息:filesystem 的挂载时间、最近一次写入资料的时间、最近一次检验磁碟(fsck) 的时间

Superblock 是非常重要的， 没有 Superblock ，就没有这个文件系统了，因此如果 superblock 死掉了，你的文件系统可能就需要花费很多时间去挽救

每个块都可能含有 superblock，但是我们也说一个文件系统应该仅有一个 superblock 而已，那是怎么回事？事实上除了第一个块内会含有 superblock 之外，后续的块不一定含有 superblock，而若含有 superblock 则该 superblock 主要是做为第一个块内 superblock 的备份，这样可以进行 superblock 的救援

Filesystem Description
文件系统描述

这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段(superblock, bitmap, inodemap, data block)分别介于哪一个 block 号码之间

block bitmap
块对照表

如果你想要新增文件时要使用哪个 block 来记录呢？当然是选择「空的 block」来记录。那你怎么知道哪个 block 是空的？这就得要通过 block bitmap 了，它会记录哪些 block 是空的，因此我们的系统就能够很快速的找到可使用的空间来记录

同样在你删除某些文件时，那些文件原本占用的 block 号码就得要释放出来， 此时在 block bitmap 中对应该 block 号码的标志位就得要修改成为「未使用中」

inode bitmap
与 block bitmap 是类似的功能，只是 block bitmap 记录的是使用与未使用的 block 号码， 至于 inode bitmap 则是记录使用与未使用的 inode 号码 5.挂载
在一个区被格式化为一个文件系统之后，它就可以被 Linux 操作系统使用了，只是这个时候 Linux 操作系统还找不到它，所以我们还需要把这个文件系统「注册」进 Linux 操作系统的文件体系里，这个操作就叫「挂载」 (mount)。
挂载是利用一个目录当成进入点(类似选一个现成的目录作为代理)，将文件系统放置在该目录下，也就是说，进入该目录就可以读取该文件系统的内容，类似整个文件系统只是目录树的一个文件夹(目录)。
这个进入点的目录我们称为「挂载点」。

由于整个 Linux 系统最重要的是根目录，因此根目录一定需要挂载到某个分区。 而其他的目录则可依用户自己的需求来给予挂载到不同的分去。

到这里 Linux 的文件体系的构建过程其实已经大体讲完了，总结一下就是:硬盘经过分区和格式化，每个区都成为了一个文件系统，挂载这个文件系统后就可以让 Linux 操作系统通过 VFS 访问硬盘时跟访问一个普通文件夹一样。这里通过一个在目录树中读取文件的实际例子来细讲一下目录文件和普通文件。

6.目录树的读取过程
首先我们要知道

每个文件(不管是一般文件还是目录文件)都会占用一个 inode

依据文件内容的大小来分配一个或多个 block 给该文件使用

创建一个文件后，文件完整信息分布在 3 处地方，生成 2 个新文件:

文件名记录在该文件所在目录的目录文件的 block 中，没有新文件生成

文件属性、权限信息、记录具体内容的 block 编号记录在 inode 中，inode 是新生成文件

文件具体内存记录在 block 中，block 是新生成文件

因为文件名的记录是在目录的 block 当中，「新增/删除/更名文件名」与目录的 w 权限有关

所以在 Linux/Unix 中，文件名称只是文件的一个属性，叫别名也好，叫绰号也罢，仅为了方便用户记忆和使用，但系统内部并不需要用文件名来定为文件位置，这样处理最直观的好处就是，你可以对正在使用的文件改名，换目录，甚至放到废纸篓，都不会影响当前文件的使用，这在 Windows 里是无法想象的。比如你打开个 Word 文件，然后对其进行重命名操作，Windows 会告诉你门儿都没有，关闭文件先！但在 Mac 里就毫无压力，因为 Mac 的操作系统同样采用了 inode 的设计。

创建文件过程
当在 ext2 下建立一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件

例如:假设我的一个 block 为 4 Kbytes ，而我要建立一个 100 KBytes 的文件，那么 linux 将分配一个 inode 与 25 个 block 来储存该文件

但同时请注意，由于 inode 仅有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录

创建目录过程
当在 ext2 文件系统建立一个目录时(就是新建了一个目录文件)，文件系统会分配一个 inode 与至少一块 block 给该目录

inode 记录该目录的相关权限与属性，并记录分配到的那块 block 号码

而 block 则是记录在这个目录下的文件名与该文件对应的 inode 号

block 中还会自动生成两条记录，一条是.文件夹记录，inode 指向自身，另一条是..文件夹记录，inode 指向父文件夹
从目录树中读取某个文件过程
因为文件名是记录在目录的 block 当中，因此当我们要读取某个文件时，就一定会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码，最终才会读到正确的文件的 block 内的资料。

由于目录树是由根目录开始，因此操作系统先通过挂载信息找到挂载点的 inode 号，由此得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 信息，再一层一层的往下读到正确的文件。

于是该文件的读取流程为:

/的 inode:

通过挂载点的信息找到 inode 号码为 128 的根目录 inode，且 inode 规定的权限让我们可以读取该 block 的内容(有 r 与 x)

/的 block:

经过上个步骤取得 block 的号码，并找到该内容有 etc/目录的 inode 号码(33595521)

etc/的 inode:

读取 33595521 号 inode 得知具有 r 与 x 的权限，因此可以读取 etc/的 block 内容

etc/的 block:

经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码(36628004)

passwd 的 inode:

读取 36628004 号 inode 得知具有 r 的权限，因此可以读取 passwd 的 block 内容

passwd 的 block:

最后将该 block 内容的资料读出来
inode/block 与文件大小的关系(有趣)
我们简单分析一下 EXT2 的 inode / block 与文件大小的关系。inode 要记录的资料非常多，但偏偏又只有 128bytes ， 而 inode 记录一个 block 号码要花掉 4byte ，假设我一个文件有 400MB 且每个 block 为 4K 时， 那么至少也要十万条 block 号码的记录！inode 哪有这么多空间来存储？为此我们的系统很聪明的将 inode 记录 block 号码的区域定义为 12 个直接，一个间接, 一个双间接与一个三间接记录区。这是啥？我们将 inode 的结构画一下好了。

上图最左边为 inode 本身(128 bytes)，里面有 12 个直接指向 block 号码的对照，这 12 条记录就能够直接取得 block 号码啦！至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果文件太大时，就会使用间接的 block 来记录号码。如上图中间接只是拿一个 block 来记录额外的号码而已。同理，如果文件持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录号码的 block 在哪里，实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层 block 来记录号码啦！
这样子 inode 能够指定多少个 block 呢？我们以较小的 1K block 来说明好了，可以指定的情况如下:

12 个直接指向: 12\*1K=12K

由于是直接指向，所以总共可记录 12 笔记录，因此总额大小为如上所示

间接: 256\*1K=256K

每笔 block 号码的记录会花去 4bytes，因此 1K 的大小能够记录 256 笔记录，因此一个间接可以记录的文件大小如上；

双间接: 2562561K=256 2 K

第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个号码，因此总额大小如上；

三间接: 256256256\*1K=256 3 K

第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个第三层，每个第三层可以指定 256 个号码，因此总额大小如上；

总额:将直接、间接、双间接、三间接加总，得到 12 + 256 + 256256 + 256256\*256 (K) = 16GB

此时我们知道当文件系统将 block 格式化为 1K 大小时，能够容纳的最大文件为 16GB，比较一下文件系统限制表的结果可发现是一致的！

但这个方法不能用在 2K 及 4K block 大小的计算中，因为大于 2K 的 block 将会受到 Ext2 文件系统本身的限制，所以计算的结果会不太符合

文件系统大小与磁盘读取性能
关于文件系统的使用效率，当你的一个文件系统规划的很大时，例如 100GB 这么大时，由于磁盘上的资料总是来来去去的，所以，整个文件系统上面的文件通常无法连续写在一起(block 号码不连续)，而是填入式的将资料填入没有被使用的 block 当中。如果文件写入的 block 真的分的很散，此时就会有所谓的文件资料离散的问题发生了。
如前所述，虽然我们的 ext2 在 inode 处已经将该文件所记录的 block 号码都记上了， 所以资料可以一次性读取，但是如果文件真的太过离散，确实还是会发生读取效率低的问题。因为磁盘读取头还是得要在整个文件系统中来来去去的频繁读取！果真如此，那么可以将整个文件系统内的资料全部复制出来，将该文件系统重新格式化， 再将资料给他复制回去即可解决这个问题。
此外，如果文件系统真的太大了，那么当一个文件分别记录在这个文件系统的最前面与最后面的 block 号码中， 此时会造成磁碟的机械手臂移动幅度过大(不是还会分块吗？)，也会造成资料读取效能的低落。而且读取头在搜寻整个文件系统时， 也会花费比较多的时间去搜寻。因此分区的规划并不是越大越好， 而是真的要针对你的主机用途来进行规划才行。
